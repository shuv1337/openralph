import { existsSync, mkdirSync } from "fs";
import { dirname, extname, join } from "path";
import { parsePrdItems, type PrdItem } from "./plan";
import { PLUGIN_TEMPLATE } from "./templates/plugin-template";
import { AGENTS_TEMPLATE } from "./templates/agents-template";

// Re-export for backwards compatibility
export {
  GENERATED_PLUGIN_MARKER,
  isGeneratedPlugin,
} from "./templates/plugin-template";
export {
  GENERATED_AGENTS_MARKER,
  isGeneratedAgents,
} from "./templates/agents-template";

/**
 * Default files protected by the write-guardrail plugin.
 */
export const DEFAULT_PROTECTED_FILES = [
  "prd.json",
  "progress.txt",
  ".ralph-prompt.md",
  "AGENTS.md",
] as const;

/**
 * Entries to add to .gitignore for Ralph-specific files.
 * These are runtime files that should not be committed.
 */
export const GITIGNORE_ENTRIES = [
  ".ralph-state.json",
  ".ralph-lock",
  ".ralph-done",
] as const;

/**
 * Header comment for the Ralph gitignore section.
 */
export const GITIGNORE_HEADER = "# Ralph - AI agent loop files";

/**
 * The complete gitignore block including header and entries.
 */
export function buildGitignoreBlock(): string {
  return `${GITIGNORE_HEADER}\n${GITIGNORE_ENTRIES.join("\n")}\n`;
}

export type InitOptions = {
  planFile: string;
  progressFile: string;
  promptFile: string;
  pluginFile: string;
  agentsFile: string;
  gitignoreFile: string;
  from?: string;
  force?: boolean;
};

export type InitResult = {
  created: string[];
  skipped: string[];
  warnings: string[];
  gitignoreAppended?: boolean;
};

/**
 * Metadata for generated PRD files.
 * Indicates the file was created by `ralph init` and is safe to remove with `ralph --reset`.
 */
export type PrdMetadata = {
  generated: true;
  generator: "ralph-init";
  createdAt: string;
  sourceFile?: string;
};

/**
 * Wrapper format for generated PRD files.
 * User-created PRD files can be plain arrays; generated ones use this wrapper.
 */
export type GeneratedPrd = {
  metadata: PrdMetadata;
  items: PrdItem[];
};

/**
 * Check if a PRD file was generated by ralph init (has metadata wrapper).
 */
export function isGeneratedPrd(content: string): boolean {
  const trimmed = content.trim();
  if (!trimmed.startsWith("{")) return false;
  try {
    const parsed = JSON.parse(trimmed);
    return (
      parsed &&
      typeof parsed === "object" &&
      parsed.metadata?.generated === true &&
      parsed.metadata?.generator === "ralph-init"
    );
  } catch {
    return false;
  }
}

/**
 * Check if a prompt file was generated by ralph init (has frontmatter marker).
 */
export function isGeneratedPrompt(content: string): boolean {
  return content.startsWith("---\ngenerated: true\n");
}

/**
 * Check if a progress file was generated by ralph init.
 * Uses the "Initialized via ralph init" line as the marker.
 */
export function isGeneratedProgress(content: string): boolean {
  return content.includes("- Notes: Initialized via ralph init.");
}

const DEFAULT_CATEGORY = "functional";
const DEFAULT_STEP = "Add verification steps for this item.";

/**
 * Frontmatter marker for generated prompt files.
 * This marker indicates the file was created by `ralph init` and is safe to remove with `ralph --reset`.
 */
export const GENERATED_PROMPT_MARKER = `---
generated: true
generator: ralph-init
safe_to_delete: true
---
`;

const PROMPT_TEMPLATE = `${GENERATED_PROMPT_MARKER}READ all of {{PLAN_FILE}} and {{PROGRESS_FILE}}.
Pick ONE task with passes=false (prefer highest-risk/highest-impact).
Keep changes small: one logical change per commit.
Update {{PLAN_FILE}} by setting passes=true and adding notes or steps as needed.
Append a brief entry to {{PROGRESS_FILE}} with what changed and why.
Run feedback loops before committing:
- bun run typecheck
- bun test
- bun run lint (if missing, note in {{PROGRESS_FILE}} and continue)
Commit the change (include {{PLAN_FILE}} updates).
ONLY do one task unless GLARINGLY OBVIOUS steps should run together.
Quality bar: production code, maintainable, tests when appropriate.
If you learn a critical operational detail, update AGENTS.md.
When ALL tasks complete, create .ralph-done and output <promise>COMPLETE</promise>.
NEVER GIT PUSH. ONLY COMMIT.
`;

function isMarkdownPath(path: string): boolean {
  const ext = extname(path).toLowerCase();
  return ext === ".md" || ext === ".markdown" || ext === ".mdx";
}

function resolvePlanTarget(planFile: string): { planFile: string; warning?: string } {
  if (!isMarkdownPath(planFile)) {
    return { planFile };
  }

  const target = join(dirname(planFile), "prd.json");
  return {
    planFile: target,
    warning: `Preserving markdown plan "${planFile}" and writing PRD JSON to "${target}".`,
  };
}

function ensureParentDir(path: string): void {
  const dir = dirname(path);
  if (dir === "." || dir === "/") return;
  if (!existsSync(dir)) {
    mkdirSync(dir, { recursive: true });
  }
}

/**
 * Parse gitignore content into a set of entries (excluding comments and blank lines).
 */
function parseGitignoreEntries(content: string): Set<string> {
  const entries = new Set<string>();
  for (const line of content.split("\n")) {
    const trimmed = line.trim();
    // Skip comments and blank lines
    if (!trimmed || trimmed.startsWith("#")) continue;
    entries.add(trimmed);
  }
  return entries;
}

/**
 * Update .gitignore with Ralph-specific entries.
 * Creates the file if it doesn't exist, or appends missing entries if it does.
 * 
 * @returns "created" if new file was created, "appended" if entries were added,
 *          "skipped" if all entries already present
 */
async function updateGitignore(
  gitignorePath: string,
  result: InitResult
): Promise<void> {
  const file = Bun.file(gitignorePath);
  const exists = await file.exists();

  if (!exists) {
    // Create new .gitignore with Ralph entries
    ensureParentDir(gitignorePath);
    await Bun.write(gitignorePath, buildGitignoreBlock());
    result.created.push(gitignorePath);
    return;
  }

  // Read existing content
  const content = await file.text();
  const existingEntries = parseGitignoreEntries(content);

  // Find entries that need to be added
  const missingEntries = GITIGNORE_ENTRIES.filter(
    (entry) => !existingEntries.has(entry)
  );

  if (missingEntries.length === 0) {
    // All entries already present
    result.skipped.push(gitignorePath);
    return;
  }

  // Append missing entries with header
  // Ensure file ends with newline before appending
  const hasTrailingNewline = content.endsWith("\n");
  const prefix = hasTrailingNewline ? "\n" : "\n\n";
  const block = `${prefix}${GITIGNORE_HEADER}\n${missingEntries.join("\n")}\n`;

  await Bun.write(gitignorePath, content + block);
  result.gitignoreAppended = true;
  result.created.push(gitignorePath);
}

function extractTasksFromText(content: string): string[] {
  const tasks: string[] = [];
  const seen = new Set<string>();
  let inCodeBlock = false;

  for (const line of content.split("\n")) {
    const trimmed = line.trim();
    if (trimmed.startsWith("```")) {
      inCodeBlock = !inCodeBlock;
      continue;
    }
    if (inCodeBlock || !trimmed) continue;
    if (trimmed.startsWith("#")) continue;

    let match =
      trimmed.match(/^- \[[ xX]\]\s+(.+)/) ??
      trimmed.match(/^[-*+]\s+(.+)/) ??
      trimmed.match(/^\d+[.)]\s+(.+)/);

    if (!match) continue;
    const task = match[1].trim();
    if (!task) continue;
    const key = task.toLowerCase();
    if (seen.has(key)) continue;
    seen.add(key);
    tasks.push(task);
  }

  return tasks;
}

function createTemplateItems(): PrdItem[] {
  return [
    {
      category: DEFAULT_CATEGORY,
      description: "Define the first PRD item for this project.",
      steps: [DEFAULT_STEP],
      passes: false,
    },
  ];
}

function createPrdItemsFromTasks(tasks: string[]): PrdItem[] {
  return tasks.map((task) => ({
    category: DEFAULT_CATEGORY,
    description: task,
    steps: [DEFAULT_STEP],
    passes: false,
  }));
}

function buildProgressTemplate(planFile: string): string {
  const timestamp = new Date().toISOString();
  return `# Ralph Progress

## Iteration 0 - Initialized ${timestamp}
- Plan: ${planFile}
- Notes: Initialized via ralph init.
`;
}

async function writeFileIfNeeded(
  path: string,
  content: string,
  force: boolean,
  result: InitResult,
): Promise<void> {
  const file = Bun.file(path);
  const exists = await file.exists();
  if (exists && !force) {
    result.skipped.push(path);
    return;
  }
  ensureParentDir(path);
  await Bun.write(path, content);
  result.created.push(path);
}

export async function runInit(options: InitOptions): Promise<InitResult> {
  const result: InitResult = { created: [], skipped: [], warnings: [] };
  const resolvedPlan = resolvePlanTarget(options.planFile);
  if (resolvedPlan.warning) {
    result.warnings.push(resolvedPlan.warning);
  }

  let sourceText = "";
  let sourcePath: string | null = null;

  if (options.from) {
    sourcePath = options.from;
  } else {
    const explicitPlan = Bun.file(options.planFile);
    if (await explicitPlan.exists()) {
      sourcePath = options.planFile;
    } else {
      const fallbackPlan = "plan.md";
      const fallbackFile = Bun.file(fallbackPlan);
      if (await fallbackFile.exists()) {
        sourcePath = fallbackPlan;
        result.warnings.push(`Found "${fallbackPlan}" and used it to seed PRD JSON.`);
      }
    }
  }

  if (sourcePath) {
    const sourceFile = Bun.file(sourcePath);
    if (await sourceFile.exists()) {
      sourceText = await sourceFile.text();
    } else {
      result.warnings.push(`Source file not found: ${sourcePath}`);
    }
  } else {
    result.warnings.push("No plan file found. Creating a template PRD.");
  }

  const trimmedSource = sourceText.trim();
  const looksLikeJson = trimmedSource.startsWith("{") || trimmedSource.startsWith("[");
  const parsedItems = sourceText ? parsePrdItems(sourceText) : null;
  let prdItems: PrdItem[] = [];

  if (parsedItems) {
    prdItems = parsedItems;
  } else if (sourceText) {
    const tasks = extractTasksFromText(sourceText);
    if (tasks.length > 0) {
      prdItems = createPrdItemsFromTasks(tasks);
    } else {
      prdItems = createTemplateItems();
      if (looksLikeJson) {
        result.warnings.push("Invalid PRD JSON detected. Creating a template PRD instead.");
      } else {
        result.warnings.push("Unable to extract tasks from the source plan. Creating a template PRD instead.");
      }
    }
  } else {
    prdItems = createTemplateItems();
  }

  // Wrap PRD items with metadata to mark as generated
  const generatedPrd: GeneratedPrd = {
    metadata: {
      generated: true,
      generator: "ralph-init",
      createdAt: new Date().toISOString(),
      sourceFile: sourcePath ?? undefined,
    },
    items: prdItems,
  };
  const planContent = JSON.stringify(generatedPrd, null, 2) + "\n";

  await writeFileIfNeeded(resolvedPlan.planFile, planContent, Boolean(options.force), result);
  await writeFileIfNeeded(
    options.progressFile,
    buildProgressTemplate(resolvedPlan.planFile),
    Boolean(options.force),
    result
  );
  await writeFileIfNeeded(options.promptFile, PROMPT_TEMPLATE, Boolean(options.force), result);

  // Create plugin file (respects --force)
  await writeFileIfNeeded(options.pluginFile, PLUGIN_TEMPLATE, Boolean(options.force), result);

  // Create AGENTS.md ONLY if it doesn't exist (NEVER overwrite, ignore --force)
  // This is intentionally different from other files - user's AGENTS.md is sacred
  const agentsFile = Bun.file(options.agentsFile);
  const agentsExists = await agentsFile.exists();
  if (!agentsExists) {
    ensureParentDir(options.agentsFile);
    await Bun.write(options.agentsFile, AGENTS_TEMPLATE);
    result.created.push(options.agentsFile);
  } else {
    result.skipped.push(options.agentsFile);
  }

  // Update .gitignore with Ralph-specific entries
  await updateGitignore(options.gitignoreFile, result);

  if (result.skipped.length > 0 && !options.force) {
    result.warnings.push("Some files already existed. Re-run with --force to overwrite.");
  }

  return result;
}
